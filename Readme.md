Висновки та порівняння алгоритмів

У роботі були реалізовані два підходи до видачі решти: жадібний алгоритм та алгоритм динамічного програмування (bottom-up). Для порівняння їх ефективності були проведені прості вимірювання часу виконання для різних значень суми change.

Жадібний алгоритм (find_coins_greedy)

Час виконання практично не залежить від величини суми і залишається дуже малим навіть для великих значень change.

Алгоритм перебирає лише список номіналів монет, тому його складність близька до O(k), де k — кількість номіналів.

Для канонічного набору монет [50, 25, 10, 5, 2, 1] жадібний алгоритм завжди знаходить оптимальний розмін і працює значно швидше за динамічне програмування.

Недолік полягає в тому, що для довільних наборів номіналів (наприклад, [4, 3, 1]) алгоритм може повертати неоптимальну кількість монет.

Алгоритм динамічного програмування (find_min_coins_bottom_up)

Час виконання зростає разом із сумою change, оскільки алгоритм послідовно обчислює оптимальний розмін для всіх значень від 0 до change.

Часова складність наближено дорівнює O(change · k).

Алгоритм завжди знаходить мінімальну кількість монет, незалежно від набору номіналів.

Для великих сум працює повільніше за жадібний алгоритм і потребує більше пам’яті, але гарантує оптимальний результат.

Загальний висновок

Жадібний алгоритм є дуже ефективним і доцільним у випадках, коли система монет є канонічною та важлива швидкість виконання. Алгоритм динамічного програмування варто використовувати тоді, коли необхідно гарантовано отримати мінімальну кількість монет, навіть ціною більшого часу виконання та використання пам’яті.
